//
//  MemoListViewController.swift
//  MemoCloneApp
//
//  Created by MUN JEONG SEO on 2021/02/08.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MemoListDisplayLogic: class {
}

struct TestMemoDataModel {
    var id: String?
    var title: String?
    var content: String?
    var updatedDate: String? //Date?
    var isFixed: Bool
}

typealias MemoListPage = MemoListViewController
class MemoListViewController: UIViewController, MemoListDisplayLogic {
    var interactor: MemoListBusinessLogic?
    var router: (NSObjectProtocol & MemoListRoutingLogic & MemoListDataPassing)?
    
    // MARK: Object lifecycle
    
    // section data
    let totalSectionCount = 2
    var isFixedMemoFolded: Bool = false
    
    var fixedMemoArray: [TestMemoDataModel] = []
    var nonFixedMemoArray: [TestMemoDataModel] = []
    
    // data
    let testDataArray = [TestMemoDataModel(id: "1",title: "제목1", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:24", isFixed: true),
                         TestMemoDataModel(id: "2",title: "제목2", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:25", isFixed: true),
                         TestMemoDataModel(id: "1",title: "제목3", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:26", isFixed: false),
                         TestMemoDataModel(id: "3",title: "제목4", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:27", isFixed: false),
                         TestMemoDataModel(id: "4",title: "제목5", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:28", isFixed: false),
                         TestMemoDataModel(id: "5",title: "제목6", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:29", isFixed: false),
                         TestMemoDataModel(id: "6",title: "제목7", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:27", isFixed: false),
                         TestMemoDataModel(id: "7",title: "제목8", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:28", isFixed: false),
                         TestMemoDataModel(id: "8",title: "제목9", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:29", isFixed: false),
                         TestMemoDataModel(id: "9",title: "제목10", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:27", isFixed: false),
                         TestMemoDataModel(id: "10",title: "제목11", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:28", isFixed: false),
                         TestMemoDataModel(id: "11",title: "제목12", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:29", isFixed: false),
                         TestMemoDataModel(id: "12",title: "제목13", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:27", isFixed: false),
                         TestMemoDataModel(id: "13",title: "제목14", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:28", isFixed: false),
                         TestMemoDataModel(id: "14",title: "제목15", content: "내용내용내용내용내용내용내용", updatedDate: "오전 9:29", isFixed: false)]
    
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup() {
        let viewController = self
        let interactor = MemoListInteractor()
        let presenter = MemoListPresenter()
        let router = MemoListRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
   
    
    // MARK: View lifecycle
    @IBOutlet weak var listTableView: UITableView!
    
    @IBOutlet weak var bottomTabView: UIView!
    @IBOutlet weak var totalCountLabel: UILabel!
    @IBOutlet weak var wrtieDownButton: UIButton!
    
    let paddig: CGFloat = 20
    let headerViewHeight : CGFloat = 60
        
    let sectionReuseIdentifier: String = "MemoListSectionView"
    let sectionHeight: CGFloat = 45.0
    
    let cellReuseIdentifier: String = "MemoListContentCell"
    let cellHeight: CGFloat = 70.0
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        initStyle()
        setNavigationBar(navigationItem: self.navigationItem, navigationController: self.navigationController, title: "리스트 페이지", hideTitleAtFirst: true)
        setTableView()
        
        //interactor로 서버에서 데이터 받아와서 display했다 치고
        testDisplayFunction()
    }
    
    private func initStyle() {
        self.view.do {
            $0.backgroundColor = getKeyColor()
        }
    }
    
    private func setTableView() {
        self.listTableView.do {
            $0.register(UINib.init(nibName: sectionReuseIdentifier, bundle: nil), forHeaderFooterViewReuseIdentifier: sectionReuseIdentifier)
            $0.register(UINib.init(nibName: cellReuseIdentifier, bundle: nil), forCellReuseIdentifier: cellReuseIdentifier)
            
            $0.tableHeaderView = MemoListHeaderView(frame: CGRect(x: 0, y: 0, width: self.listTableView.frame.width, height: headerViewHeight))
            
            let footerView = UIView(frame: CGRect(x: 0, y: 0, width: self.listTableView.frame.width, height: 60.0))
            footerView.backgroundColor = .clear
            $0.tableFooterView = footerView
            
            $0.delegate = self
            $0.dataSource = self
            //$0.addInteraction(UIContextMenuInteraction(delegate: self))
            
            $0.backgroundColor = .clear
            $0.separatorStyle = .singleLine
            $0.showsVerticalScrollIndicator = false
            $0.showsHorizontalScrollIndicator = false
        }
    }
    
    private func setTotalCountText(totalCount: Int?) {
        guard let count = totalCount else {
            self.totalCountLabel.text = ""
            return
        }
        self.totalCountLabel.text = "총 \(count)개"
    }
    
    @IBAction func handleWrtieDownBTNTap(_ sender: Any) {
        let destinationVc = MemoDetailViewController()
        self.navigationController?.pushViewController(destinationVc, animated: true)
    }
    
    // MARK: Do something
    
    func displaySomething(viewModel: MemoList.Something.ViewModel) {
        //nameTextField.text = viewModel.name
    }
    
    func testDisplayFunction() {
        for data in self.testDataArray {
            if data.isFixed {
                self.fixedMemoArray.append(data)
            } else {
                self.nonFixedMemoArray.append(data)
            }
        }
        
        listTableView.reloadData()
        
        setTotalCountText(totalCount: self.testDataArray.count)
    }
}

extension MemoListViewController : UITableViewDataSource { //UIContextMenuInteractionDelegate
    
    // SECTION
    func numberOfSections(in tableView: UITableView) -> Int {
        return totalSectionCount
    }
    
    // CELL
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        let dataArray = section == 0 ? fixedMemoArray : nonFixedMemoArray
        
        guard !dataArray.isEmpty  else {
            return 0
        }
        
        return dataArray.count
    }
    
    // SECTION
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let view = tableView.dequeueReusableHeaderFooterView(withIdentifier: sectionReuseIdentifier) as! MemoListSectionView

        if section == 0 {
            view.updateSectionData(style: MemoListSectionStyle.FixVersion, isFolded: isFixedMemoFolded)
        } else {
            view.updateSectionData(style: MemoListSectionStyle.NormalVersion)
        }
        
        view.delegate = self
        
        return view
    }
        
    // CELL
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
       
        // - empty
        guard !testDataArray.isEmpty, testDataArray.count > indexPath.row else {
            return UITableViewCell()
        }
        
        // - 해당 셀
        var data: TestMemoDataModel?
        let dataArray = indexPath.section == 0 ? fixedMemoArray : nonFixedMemoArray
        
        guard !dataArray.isEmpty, dataArray.count > indexPath.row  else {
            return UITableViewCell()
        }
        data = dataArray[indexPath.row]
        
        let cell = tableView.dequeueReusableCell(withIdentifier: cellReuseIdentifier, for: indexPath) as! MemoListContentCell
        cell.updateData(title: data?.title, content: data?.content, savedDate: data?.updatedDate ?? "")
        
        return cell
    }
    
}

extension MemoListViewController : UITableViewDelegate {
    // HEADER
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        if fixedMemoArray.isEmpty {
            // 고정 메모 1개도 없으면 섹션 다 없애기
            return 0
        } else {
            return sectionHeight
        }
    }
    
    // CELL
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if isFixedMemoFolded, indexPath.section == 0 {
            return 0
        } else {
            return cellHeight
        }
    }
    
    // CELL
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: false)
        
        guard testDataArray.count > indexPath.row else {
            return
        }
        
        let dataArray = indexPath.section == 0 ? fixedMemoArray : nonFixedMemoArray
        
        guard dataArray.count > indexPath.row else {
            return
        }
        
        let destinationVc = MemoDetailViewController(data: dataArray[indexPath.row])
        self.navigationController?.pushViewController(destinationVc, animated: true)
    }
    
    // CELL
    func tableView(_ tableView: UITableView, contextMenuConfigurationForRowAt indexPath: IndexPath, point: CGPoint) -> UIContextMenuConfiguration? {
        //print("contextMenuConfigurationForRowAt section:", indexPath.section, ", cell:", indexPath.row, ", point:", point)
        
        let actionProvider: UIContextMenuActionProvider = { _ in
                return UIMenu(children: [
                    UIAction(title: "메모 고정", image: UIImage(systemName: "pin")) { _ in
                        print("메모고정 하기")
                    },
                    UIAction(title: "메모 삭제", image: UIImage(systemName: "trash"), attributes: UIMenuElement.Attributes.destructive) { _ in
                        print("메모삭제 하기")
                    }
                ])
            }
            return UIContextMenuConfiguration(identifier: indexPath as NSCopying,
                                               previewProvider: nil,
                                               actionProvider: actionProvider)
    }
    
    // CELL swipe action
    func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt: IndexPath) -> UISwipeActionsConfiguration? { // 셀에서 스와이프에 의해 생성되는 메뉴를 셀의 앞에 보여준다
        let contextItem = UIContextualAction(style: .destructive, title: "고정") {  (contextualAction, view, boolValue) in
            //Code I want to do here
        }
        contextItem.backgroundColor = UIColor.orange
        contextItem.image = UIImage(systemName: "pin")
        
        let swipeActions = UISwipeActionsConfiguration(actions: [contextItem])
        
        return swipeActions
    }

    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt: IndexPath) -> UISwipeActionsConfiguration? { // 셀에서 스와이프에 의해 생성되는 메뉴를 셀의 뒤에 보여준다
        let contextItem = UIContextualAction(style: .destructive, title: "삭제") {  (contextualAction, view, boolValue) in
            //Code I want to do here
        }
        contextItem.backgroundColor = UIColor.red
        contextItem.image = UIImage(systemName: "trash")
        
        let swipeActions = UISwipeActionsConfiguration(actions: [contextItem])
        
        return swipeActions
    }
    
    // CELL context menu
    func tableView(_ tableView: UITableView, willPerformPreviewActionForMenuWith configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionCommitAnimating) {
        guard let indexPath = configuration.identifier as? IndexPath else { return }
        
        let dataArray = indexPath.section == 0 ? fixedMemoArray : nonFixedMemoArray
        
        guard dataArray.count > indexPath.row else {
            return
        }
        
        let destinationVc = MemoDetailViewController(data: dataArray[indexPath.row])
        animator.addAnimations {
            self.navigationController?.pushViewController(destinationVc, animated: true)
        }
    }
    
    func tableView(_ tableView: UITableView, previewForDismissingContextMenuWithConfiguration configuration: UIContextMenuConfiguration) -> UITargetedPreview? {
        print("previewForDismissingContextMenuWithConfiguration:", configuration)
        return nil
    }
    
    func tableView(_ tableView: UITableView, previewForHighlightingContextMenuWithConfiguration configuration: UIContextMenuConfiguration) -> UITargetedPreview? {
        print("previewForHighlightingContextMenuWithConfiguration:", configuration)
        return nil
    }
}

extension MemoListViewController: MemoListSectionCellDelegate {
    func handlFoldAndStretchButtonTap(isFolded: Bool) {
        self.isFixedMemoFolded = isFolded
        self.listTableView.reloadSections(IndexSet.init(integer: 0), with: .fade)
    }
}

extension MemoListViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        //print("scrolled y:",scrollView.contentOffset.y)
        
        if (scrollView.contentOffset.y < headerViewHeight / 2) {
            //네비게이션 바 이름 지우기
            hideNavigationBarTitle(navigationItem: self.navigationItem, navigationController: self.navigationController)
        } else {
           //네비게이션 바 이름 쓰기
            showNavigationBarTitle(navigationItem: self.navigationItem, navigationController: self.navigationController)
        }
    }
}

//MARK: 탭바 사용 현타옴
//private func setTabBar(tabBarController: UITabBarController?) {
//    guard let selectedVC = tabBarController?.selectedViewController else { return }
//
//    switch selectedVC.children.last {
//    case is MemoListViewController:
//        selectedVC.tabBarItem.title = "총 \(self.testDataArray.count)개"
//        selectedVC.tabBarItem.setTitleTextAttributes([NSAttributedString.Key.foregroundColor: UIColor.darkGray, NSAttributedString.Key.font: UIFont.systemFont(ofSize: 11)], for: .normal)
//    default:
//        <#code#>
//    }
//
//    if selectedVC.children.last is MemoListViewController {
//        selectedVC.tabBarItem.title = "총 \(self.testDataArray.count)개"
//        selectedVC.tabBarItem.setTitleTextAttributes([NSAttributedString.Key.foregroundColor: UIColor.darkGray, NSAttributedString.Key.font: UIFont.systemFont(ofSize: 11)], for: .normal)
//    } else {
//        selectedVC.tabBarItem = nil
//    }
//
//}

//MARK: 디프리케이트 됨
//    func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]?
//    {
    //    guard let memoLogList = testDataArray, memoLogList.count > 0 else {​​​​​ return nil }
    //    let deleteAction = UITableViewRowAction(style: .destructive, title: "숨기기") {​​​​​ (action, indexpath) in
    //      //테이블 뷰 업데이트
    //    }
    //
    //    deleteAction.backgroundColor = .black
    //    return [deleteAction]
//        return nil
//    }

//func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
    // - empty
    //    guard (testDataArray.count ?? 0) > 0 else {
    //      var bottomSafeAreaGap:CGFloat = 0.0
    //      if #available(iOS 11.0, *) {
    //        bottomSafeAreaGap = view.safeAreaInsets.bottom
    //      }​​​​​ else {
    //        bottomSafeAreaGap = bottomLayoutGuide.length
    //      }
    //
    //      let emptyCellHeight = (self.cardHistoryTableView.frame.height) - bottomSafeAreaGap - (self.headerView.frame.height)
    //      return emptyCellHeight
    //    }
//    return cellHeight
//}
