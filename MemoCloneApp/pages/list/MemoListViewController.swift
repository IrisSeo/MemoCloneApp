//
//  MemoListViewController.swift
//  MemoCloneApp
//
//  Created by MUN JEONG SEO on 2021/02/08.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MemoListDisplayLogic: class {
    func displayMemoListSuccess(viewModel: [MemoData]?)
    func displayMemoListFail()
    func displayDeleteSuccess()
    func displayDeleteFail()
    func displayChangeIsFixedSuccess(viewModel: [MemoData]?)
    func displayChangeIsFixedFail()
}

typealias MemoListPage = MemoListViewController
class MemoListViewController: UIViewController, MemoListDisplayLogic {
    var interactor: MemoListBusinessLogic?
    var router: (NSObjectProtocol & MemoListRoutingLogic & MemoListDataPassing)?
    
    // MARK: Object lifecycle
    
    // section data
    let totalSectionCount = 2
    var isFixedMemoFolded: Bool = false
    
    // data
    var totalMemoArray = [MemoData]()
    var fixedMemoArray = [MemoData]()
    var nonFixedMemoArray = [MemoData]()
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup() {
        let viewController = self
        let interactor = MemoListInteractor()
        let presenter = MemoListPresenter()
        let router = MemoListRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
   
    
    // MARK: View lifecycle
    @IBOutlet weak var listTableView: UITableView!
    
    @IBOutlet weak var bottomTabView: UIView!
    @IBOutlet weak var totalCountLabel: UILabel!
    @IBOutlet weak var wrtieDownButton: UIButton!
    
    let paddig: CGFloat = 20
    let headerViewHeight : CGFloat = 60
        
    let sectionReuseIdentifier: String = "MemoListSectionView"
    let sectionHeight: CGFloat = 45.0
    
    let cellReuseIdentifier: String = "MemoListContentCell"
    let cellHeight: CGFloat = 70.0
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        initStyle()
        setNavigationBar(navigationItem: self.navigationItem, navigationController: self.navigationController, title: "리스트 페이지", hideTitleAtFirst: true)
        setTableView()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(true)
        
        self.requestMemoList()
    }
    
    private func requestMemoList() {
        // default
        totalMemoArray = [MemoData]()
        fixedMemoArray = [MemoData]()
        nonFixedMemoArray = [MemoData]()
        
        self.interactor?.requestMemoList()
    }
    
    private func initStyle() {
        self.view.do {
            $0.backgroundColor = getKeyColor()
        }
    }
    
    private func setTableView() {
        self.listTableView.do {
            $0.register(UINib.init(nibName: sectionReuseIdentifier, bundle: nil), forHeaderFooterViewReuseIdentifier: sectionReuseIdentifier)
            $0.register(UINib.init(nibName: cellReuseIdentifier, bundle: nil), forCellReuseIdentifier: cellReuseIdentifier)
            
            $0.tableHeaderView = MemoListHeaderView(frame: CGRect(x: 0, y: 0, width: self.listTableView.frame.width, height: headerViewHeight))
            
            let footerView = UIView(frame: CGRect(x: 0, y: 0, width: self.listTableView.frame.width, height: 60.0))
            footerView.backgroundColor = .clear
            $0.tableFooterView = footerView
            
            $0.delegate = self
            $0.dataSource = self
            //$0.addInteraction(UIContextMenuInteraction(delegate: self))
            
            $0.backgroundColor = .clear
            $0.separatorStyle = .singleLine
            $0.showsVerticalScrollIndicator = false
            $0.showsHorizontalScrollIndicator = false
        }
    }
    
    private func setTotalCountText(totalCount: Int?) {
        guard let count = totalCount else {
            self.totalCountLabel.text = ""
            return
        }
        self.totalCountLabel.text = "총 \(count)개"
    }
    
    private func isFixedSection(section: Int) -> Bool {
        return  section == 0 && !fixedMemoArray.isEmpty
    }
    
    @IBAction func handleWrtieDownBTNTap(_ sender: Any) {
        let destinationVc = MemoDetailViewController()
        self.navigationController?.pushViewController(destinationVc, animated: true)
    }
    
    // MARK: Do something
    
    func displayMemoListSuccess(viewModel: [MemoData]?) {
        guard let totalMemoArray = viewModel else {
            print("저장된 메모 없음")
            return
        }
        
        //update data
        self.totalMemoArray = totalMemoArray
        for data in self.totalMemoArray {
            if data.isFixed {
                self.fixedMemoArray.append(data)
            } else {
                self.nonFixedMemoArray.append(data)
            }
        }
        
        //update view
        listTableView.reloadData()
        setTotalCountText(totalCount: self.totalMemoArray.count)
    }
    
    func displayMemoListFail() {
        showOKAlert(vc: self, title: "메모 불러오기 실패", message: "에러가 발생하였습니다.")
    }
    
    func displayDeleteSuccess() {
        showOKAlert(vc: self, title: "메모 삭제 성공", message: "정상적으로 삭제되었습니다.")
    }
    
    func displayDeleteFail() {
        showOKAlert(vc: self, title: "메모 삭제 실패", message: "에러가 발생하였습니다.")
    }
    
    func displayChangeIsFixedSuccess(viewModel: [MemoData]?) {
        //MARK: [이슈] 전체 값 말고 하나만 업데이트 되게 수정
        guard let totalMemoArray = viewModel else {
            print("저장된 메모 없음")
            return
        }
        
        //update data
        self.totalMemoArray = totalMemoArray
        for data in self.totalMemoArray {
            if data.isFixed {
                self.fixedMemoArray.append(data)
            } else {
                self.nonFixedMemoArray.append(data)
            }
        }
        
        //update view
        listTableView.reloadData()
        setTotalCountText(totalCount: self.totalMemoArray.count)
    }
    
    func displayChangeIsFixedFail() {
        showOKAlert(vc: self, title: "메모 상단고정 실패", message: "에러가 발생하였습니다.")
    }
    
}

extension MemoListViewController : UITableViewDataSource {
    
    // SECTION
    func numberOfSections(in tableView: UITableView) -> Int {
        
        guard totalMemoArray.count > 0 else {
            //데이터 없음
            return 0
        }
        
        var countSection = totalSectionCount
        if fixedMemoArray.isEmpty {
            countSection -= 1
        } else if nonFixedMemoArray.isEmpty {
            countSection -= 1
        }
        
        return countSection
    }
    
    // CELL
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        guard totalMemoArray.count > 0 else {
            //데이터 없음
            return 0
        }
        
        let dataArray = isFixedSection(section: section) ? fixedMemoArray : nonFixedMemoArray
        
        guard !dataArray.isEmpty  else {
            return 0
        }
        
        return dataArray.count
    }
    
    // SECTION
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let view = tableView.dequeueReusableHeaderFooterView(withIdentifier: sectionReuseIdentifier) as! MemoListSectionView

        if isFixedSection(section: section) {
            view.updateSectionData(style: MemoListSectionStyle.FixVersion, isFolded: isFixedMemoFolded)
        } else {
            view.updateSectionData(style: MemoListSectionStyle.NormalVersion)
        }
        
        view.delegate = self
        
        return view
    }
        
    // CELL
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
       
        // - empty
        guard totalMemoArray.count > 0 else {
            return UITableViewCell()
        }
        
        // - 해당 셀
        var data: MemoData?
        let dataArray = isFixedSection(section: indexPath.section) ? fixedMemoArray : nonFixedMemoArray
        
        guard !dataArray.isEmpty, dataArray.count > indexPath.row  else {
            return UITableViewCell()
        }
        data = dataArray[indexPath.row]
        
        let cell = tableView.dequeueReusableCell(withIdentifier: cellReuseIdentifier, for: indexPath) as! MemoListContentCell
        cell.updateData(title: data?.title, content: data?.content, savedDate: data?.updatedDate)
        
        return cell
    }
    
}

extension MemoListViewController : UITableViewDelegate {
    // HEADER
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        if fixedMemoArray.isEmpty {
            // 고정 메모 1개도 없으면 섹션 헤더 다 없애기
            return 0
        } else {
            return sectionHeight
        }
    }
    
    // CELL
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if isFixedMemoFolded && isFixedSection(section: indexPath.section) {
             return 0
        } else {
            return cellHeight
        }
    }
    
    // CELL
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: false)
        
        guard totalMemoArray.count > 0 else {
            return
        }
        
        let dataArray = isFixedSection(section: indexPath.section) ? fixedMemoArray : nonFixedMemoArray
        
        guard dataArray.count > indexPath.row else {
            return
        }
        
        let destinationVc = MemoDetailViewController(data: dataArray[indexPath.row])
        self.navigationController?.pushViewController(destinationVc, animated: true)
    }
    
    // CELL
    func tableView(_ tableView: UITableView, contextMenuConfigurationForRowAt indexPath: IndexPath, point: CGPoint) -> UIContextMenuConfiguration? {
        //print("contextMenuConfigurationForRowAt section:", indexPath.section, ", cell:", indexPath.row, ", point:", point)
        
        let actionProvider: UIContextMenuActionProvider = { _ in
                return UIMenu(children: [
                    UIAction(title: "메모 고정", image: UIImage(systemName: "pin")) { _ in
                        print("메모고정 하기")
                    },
                    UIAction(title: "메모 삭제", image: UIImage(systemName: "trash"), attributes: UIMenuElement.Attributes.destructive) { _ in
                        print("메모삭제 하기")
                    }
                ])
            }
            return UIContextMenuConfiguration(identifier: indexPath as NSCopying,
                                               previewProvider: nil,
                                               actionProvider: actionProvider)
    }
    
    // CELL swipe action
    func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt: IndexPath) -> UISwipeActionsConfiguration? { // 셀에서 스와이프에 의해 생성되는 메뉴를 셀의 앞에 보여준다
        let contextItem = UIContextualAction(style: .normal, title: "고정") {  (contextualAction, view, boolValue) in
            //Code I want to do here
        }
        contextItem.backgroundColor = UIColor.orange
        contextItem.image = isFixedSection(section: leadingSwipeActionsConfigurationForRowAt.section) ? UIImage(systemName: "pin.slash") : UIImage(systemName: "pin")
        
        let swipeActions = UISwipeActionsConfiguration(actions: [contextItem])
        
        return swipeActions
    }

    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt: IndexPath) -> UISwipeActionsConfiguration? { // 셀에서 스와이프에 의해 생성되는 메뉴를 셀의 뒤에 보여준다
        let contextItem = UIContextualAction(style: .destructive, title: "삭제") {  (contextualAction, view, boolValue) in
            //Code I want to do here
        }
        contextItem.backgroundColor = UIColor.red
        contextItem.image = UIImage(systemName: "trash")
        
        let swipeActions = UISwipeActionsConfiguration(actions: [contextItem])
        
        return swipeActions
    }
    
    // CELL context menu
    func tableView(_ tableView: UITableView, willPerformPreviewActionForMenuWith configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionCommitAnimating) {
        guard let indexPath = configuration.identifier as? IndexPath else { return }
        
        let dataArray = isFixedSection(section: indexPath.section) ? fixedMemoArray : nonFixedMemoArray
        
        guard dataArray.count > indexPath.row else {
            return
        }
        
        let destinationVc = MemoDetailViewController(data: dataArray[indexPath.row])
        animator.addAnimations {
            self.navigationController?.pushViewController(destinationVc, animated: true)
        }
    }
    
    func tableView(_ tableView: UITableView, previewForDismissingContextMenuWithConfiguration configuration: UIContextMenuConfiguration) -> UITargetedPreview? {
        print("previewForDismissingContextMenuWithConfiguration:", configuration)
        return nil
    }
    
    func tableView(_ tableView: UITableView, previewForHighlightingContextMenuWithConfiguration configuration: UIContextMenuConfiguration) -> UITargetedPreview? {
        print("previewForHighlightingContextMenuWithConfiguration:", configuration)
        return nil
    }
}

extension MemoListViewController: MemoListSectionCellDelegate {
    func handleFoldAndStretchButtonTap(isFolded: Bool) {
        self.isFixedMemoFolded = isFolded
        self.listTableView.reloadSections(IndexSet.init(integer: 0), with: .fade)
    }
}

extension MemoListViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        //print("scrolled y:",scrollView.contentOffset.y)
        
        if (scrollView.contentOffset.y < headerViewHeight / 2) {
            //네비게이션 바 이름 지우기
            hideNavigationBarTitle(navigationItem: self.navigationItem, navigationController: self.navigationController)
        } else {
           //네비게이션 바 이름 쓰기
            showNavigationBarTitle(navigationItem: self.navigationItem, navigationController: self.navigationController)
        }
    }
}
