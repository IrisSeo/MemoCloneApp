//
//  MemoListViewController.swift
//  MemoCloneApp
//
//  Created by MUN JEONG SEO on 2021/02/08.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MemoListDisplayLogic: class {
    func displayMemoList(viewModel: MemoList.조회.ViewModel)
    func displayDeleteMemo(viewModel: MemoList.삭제.ViewModel)
    func displayChangeFixStatus(viewModel: MemoList.고정상태_수정.ViewModel)
}

typealias MemoListPage = MemoListViewController
class MemoListViewController: UIViewController, MemoListDisplayLogic {
    var interactor: MemoListBusinessLogic?
    var router: (NSObjectProtocol & MemoListRoutingLogic & MemoListDataPassing)?
    
    // MARK: Object lifecycle
    
    // section data
    let totalSectionCount = 2 //고정, 비고정 섹터
    var isFixedMemoFolded: Bool = false
    
    // data
    var totalMemoArray = [MemoData]()
    var fixedMemoArray = [MemoData]()
    var nonFixedMemoArray = [MemoData]()
    
    var selecteMemoKey: String?
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup() {
        let viewController = self
        let interactor = MemoListInteractor()
        let presenter = MemoListPresenter()
        let router = MemoListRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    
    // MARK: View lifecycle
    @IBOutlet weak var listTableView: UITableView!
    
    @IBOutlet weak var bottomTabView: UIView!
    @IBOutlet weak var totalCountLabel: UILabel!
    @IBOutlet weak var wrtieDownButton: UIButton!
    
    let paddig: CGFloat = 20
    let headerViewHeight : CGFloat = 60
    
    let sectionReuseIdentifier: String = "MemoListSectionView"
    let sectionHeight: CGFloat = 45.0
    
    let cellReuseIdentifier: String = "MemoListContentCell"
    let cellHeight: CGFloat = 70.0
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        initStyle()
        setNavigationBar(navigationItem: self.navigationItem, navigationController: self.navigationController, title: "리스트", hideTitleAtFirst: true)
        setTableView()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(true)
        
        self.requestMemoList()
    }
    
    private func initStyle() {
        self.view.do {
            $0.backgroundColor = getKeyColor()
        }
    }
    
    private func setTableView() {
        self.listTableView.do {
            $0.register(UINib.init(nibName: sectionReuseIdentifier, bundle: nil), forHeaderFooterViewReuseIdentifier: sectionReuseIdentifier)
            $0.register(UINib.init(nibName: cellReuseIdentifier, bundle: nil), forCellReuseIdentifier: cellReuseIdentifier)
            
            $0.tableHeaderView = MemoListHeaderView(frame: CGRect(x: 0, y: 0, width: self.listTableView.frame.width, height: headerViewHeight))
            
            let footerView = UIView(frame: CGRect(x: 0, y: 0, width: self.listTableView.frame.width, height: 60.0))
            footerView.backgroundColor = .clear
            $0.tableFooterView = footerView
            
            $0.delegate = self
            $0.dataSource = self
            
            $0.backgroundColor = .clear
            $0.separatorStyle = .singleLine
            $0.showsVerticalScrollIndicator = false
            $0.showsHorizontalScrollIndicator = false
        }
    }
    
    @IBAction func handleWrtieDownBTNTap(_ sender: Any) {
        self.router?.routeToMemoDetailPage()
    }
    
    private func requestMemoList() {
        // default
        totalMemoArray = [MemoData]()
        fixedMemoArray = [MemoData]()
        nonFixedMemoArray = [MemoData]()
        
        self.interactor?.requestMemoList()
    }
    
    private func changeMemoIsFixedStatus(key: String?, to fix: Bool) {
        self.interactor?.changeMemoFixStatus(key: key, isFixed: fix)
    }
    
    private func deleteMemo(key: String?) {
        self.interactor?.deleteMemo(key: key)
    }
    
    // MARK: Do something
    func displayMemoList(viewModel: MemoList.조회.ViewModel) {
        guard let memoDataArray = viewModel.memoArray else {
            showOKAlert(vc: self, title: "메모 불러오기 실패", message: "에러가 발생하였습니다.") //MARK: error 분기치기(데이터 없음 vs 데이터 조회 실패)
            return
        }
        
        //update data
        updateMemoDataList(vmDataList: memoDataArray)
        updateBottomCountText(totalCount: memoDataArray.count)
        
        //update view
        listTableView.reloadData()
    }
    
    func displayDeleteMemo(viewModel: MemoList.삭제.ViewModel) {
        if viewModel.isDeleteSuccess {
            let okAction = UIAlertAction(title: "OK", style: .default) { (action) in
                self.requestMemoList()
            }
            showOKAlert(vc: self, title: "메모 삭제 성공", message: "정상적으로 삭제되었습니다.", okAction: okAction)
        } else {
            showOKAlert(vc: self, title: "메모 삭제 실패", message: "에러가 발생하였습니다.")
        }
    }
    
    func displayChangeFixStatus(viewModel: MemoList.고정상태_수정.ViewModel) {
        let toStatus = viewModel.toStatus == .고정 ? "고정" : "고정해제"
        if viewModel.isChangeSuccess {
            let okAction = UIAlertAction(title: "OK", style: .default) { (action) in
                self.requestMemoList()
            }
            showOKAlert(vc: self, title: "메모 \(toStatus) 성공", message: "정상적으로 \(toStatus) 되었습니다.", okAction: okAction)
        } else {
            showOKAlert(vc: self, title: toStatus, message: "에러가 발생하였습니다.")
        }
    }
    
    private func updateMemoDataList(vmDataList: [MemoData]) {
        self.totalMemoArray = vmDataList
        for data in self.totalMemoArray {
            if data.isFixed {
                self.fixedMemoArray.append(data)
            } else {
                self.nonFixedMemoArray.append(data)
            }
        }
    }
    
    private func updateBottomCountText(totalCount: Int?) {
        guard let count = totalCount else {
            self.totalCountLabel.text = ""
            return
        }
        self.totalCountLabel.text = "총 \(count)개"
    }
}

extension MemoListViewController : UITableViewDataSource {
    private func isFixedSection(section: Int) -> Bool {
        return  section == 0 && !fixedMemoArray.isEmpty
    }
    
    // SECTION
    func numberOfSections(in tableView: UITableView) -> Int {
        
        guard totalMemoArray.count > 0 else {
            //데이터 없음
            return 0
        }
        
        var countSection = totalSectionCount
        if fixedMemoArray.isEmpty {
            countSection -= 1
        } else if nonFixedMemoArray.isEmpty {
            countSection -= 1
        }
        
        return countSection
    }
    
    // CELL
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        guard totalMemoArray.count > 0 else {
            //데이터 없음
            return 0
        }
        
        let dataArray = isFixedSection(section: section) ? fixedMemoArray : nonFixedMemoArray
        
        guard !dataArray.isEmpty  else {
            return 0
        }
        
        return dataArray.count
    }
    
    // SECTION
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let view = tableView.dequeueReusableHeaderFooterView(withIdentifier: sectionReuseIdentifier) as! MemoListSectionView
        
        if isFixedSection(section: section) {
            view.updateSectionData(style: MemoListSectionStyle.FixVersion, isFolded: isFixedMemoFolded)
        } else {
            view.updateSectionData(style: MemoListSectionStyle.NormalVersion)
        }
        
        view.delegate = self
        
        return view
    }
    
    // CELL
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        // - empty
        guard totalMemoArray.count > 0 else {
            return UITableViewCell()
        }
        
        // - 해당 셀
        var data: MemoData?
        let dataArray = isFixedSection(section: indexPath.section) ? fixedMemoArray : nonFixedMemoArray
        
        guard !dataArray.isEmpty, dataArray.count > indexPath.row  else {
            return UITableViewCell()
        }
        data = dataArray[indexPath.row]
        
        let cell = tableView.dequeueReusableCell(withIdentifier: cellReuseIdentifier, for: indexPath) as! MemoListContentCell
        cell.updateData(title: data?.title, content: data?.content, savedDate: data?.updatedDate)
        
        return cell
    }
    
}

extension MemoListViewController: MemoListSectionCellDelegate {
    func handleFoldAndStretchButtonTap(isFolded: Bool) {
        self.isFixedMemoFolded = isFolded
        self.listTableView.reloadSections(IndexSet.init(integer: 0), with: .fade)
    }
}

extension MemoListViewController : UITableViewDelegate {
    // HEADER
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        if fixedMemoArray.isEmpty {
            // 고정 메모 1개도 없으면 섹션 헤더 다 없애기
            return 0
        } else {
            return sectionHeight
        }
    }
    
    // CELL
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        if isFixedMemoFolded && isFixedSection(section: indexPath.section) {
            return 0
        } else {
            return cellHeight
        }
    }
    
    // CELL
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: false)
        
        guard totalMemoArray.count > 0 else {
            return
        }
        
        let dataArray = isFixedSection(section: indexPath.section) ? fixedMemoArray : nonFixedMemoArray
        
        guard dataArray.count > indexPath.row else {
            return
        }
        
        self.selecteMemoKey = dataArray[indexPath.row].key
        self.router?.routeToMemoDetailPageWithData()
    }
    
    // CELL
    func tableView(_ tableView: UITableView, contextMenuConfigurationForRowAt indexPath: IndexPath, point: CGPoint) -> UIContextMenuConfiguration? {
        
        let isFixedSection = self.isFixedSection(section: indexPath.section)
        let fixImage = isFixedSection ? UIImage(systemName: "pin.slash") : UIImage(systemName: "pin")
        
        let dataArray = isFixedSection ? fixedMemoArray : nonFixedMemoArray
        let memoData = dataArray[indexPath.row]
        
        guard dataArray.count > indexPath.row else {
            return nil
        }
        
        let actionProvider: UIContextMenuActionProvider = { _ in
            return UIMenu(children: [
                UIAction(title: "메모 고정", image: fixImage) { _ in
                    print("메모 고정 하기")
                    self.changeMemoIsFixedStatus(key: memoData.key, to: !isFixedSection)
                },
                UIAction(title: "메모 삭제", image: UIImage(systemName: "trash"), attributes: UIMenuElement.Attributes.destructive) { _ in
                    print("메모 삭제 하기")
                    self.deleteMemo(key: memoData.key)
                }
            ])
        }
        return UIContextMenuConfiguration(identifier: indexPath as NSCopying,
                                          previewProvider: nil,
                                          actionProvider: actionProvider)
    }
    
    // CELL swipe action
    func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt: IndexPath) -> UISwipeActionsConfiguration? { // 셀에서 스와이프에 의해 생성되는 메뉴를 셀의 앞에 보여준다
        
        let isFixedSection = self.isFixedSection(section: leadingSwipeActionsConfigurationForRowAt.section)
        let dataArray = isFixedSection ? fixedMemoArray : nonFixedMemoArray
        let memoData = dataArray[leadingSwipeActionsConfigurationForRowAt.row]
        
        guard dataArray.count > leadingSwipeActionsConfigurationForRowAt.row else {
            return nil
        }
        
        let contextItem = UIContextualAction(style: .normal, title: "고정") {  (contextualAction, view, boolValue) in
            //Code I want to do here
            print("메모 삭제 하기")
            self.changeMemoIsFixedStatus(key: memoData.key, to: !isFixedSection)
        }
        contextItem.backgroundColor = UIColor.orange
        contextItem.image = isFixedSection ? UIImage(systemName: "pin.slash") : UIImage(systemName: "pin")
        
        let swipeActions = UISwipeActionsConfiguration(actions: [contextItem])
        
        return swipeActions
    }
    
    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt: IndexPath) -> UISwipeActionsConfiguration? { // 셀에서 스와이프에 의해 생성되는 메뉴를 셀의 뒤에 보여준다
        let isFixedSection = self.isFixedSection(section: trailingSwipeActionsConfigurationForRowAt.section)
        let dataArray = isFixedSection ? fixedMemoArray : nonFixedMemoArray
        let memoData = dataArray[trailingSwipeActionsConfigurationForRowAt.row]
        
        guard dataArray.count > trailingSwipeActionsConfigurationForRowAt.row else {
            return nil
        }
        
        let contextItem = UIContextualAction(style: .destructive, title: "삭제") {  (contextualAction, view, boolValue) in
            print("메모 삭제 하기")
            self.deleteMemo(key: memoData.key)
        }
        contextItem.backgroundColor = UIColor.red
        contextItem.image = UIImage(systemName: "trash")
        
        let swipeActions = UISwipeActionsConfiguration(actions: [contextItem])
        
        return swipeActions
    }
    
    // CELL context menu
    func tableView(_ tableView: UITableView, willPerformPreviewActionForMenuWith configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionCommitAnimating) {
        guard let indexPath = configuration.identifier as? IndexPath else { return }
        
        let dataArray = isFixedSection(section: indexPath.section) ? fixedMemoArray : nonFixedMemoArray
        
        guard dataArray.count > indexPath.row else {
            return
        }
        
        animator.addAnimations {
            self.selecteMemoKey = dataArray[indexPath.row].key
            self.router?.routeToMemoDetailPageWithData()
        }
    }
    
    func tableView(_ tableView: UITableView, previewForDismissingContextMenuWithConfiguration configuration: UIContextMenuConfiguration) -> UITargetedPreview? {
        print("previewForDismissingContextMenuWithConfiguration:", configuration)
        return nil
    }
    
    func tableView(_ tableView: UITableView, previewForHighlightingContextMenuWithConfiguration configuration: UIContextMenuConfiguration) -> UITargetedPreview? {
        print("previewForHighlightingContextMenuWithConfiguration:", configuration)
        return nil
    }
}

extension MemoListViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        //print("scrolled y:",scrollView.contentOffset.y)
        
        if (scrollView.contentOffset.y < headerViewHeight / 2) {
            //네비게이션 바 이름 지우기
            hideNavigationBarTitle(navigationItem: self.navigationItem, navigationController: self.navigationController)
        } else {
            //네비게이션 바 이름 쓰기
            showNavigationBarTitle(navigationItem: self.navigationItem, navigationController: self.navigationController)
        }
    }
}
